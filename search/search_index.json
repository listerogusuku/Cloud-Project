{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AWS S3 SERVELESS APPLICATION | CLOUD COMPUTING - INSPER","text":"<ul> <li>Alunos: Lister Ogusuku Ribeiro</li> <li>Curso: Engenharia da Computa\u00e7\u00e3o</li> <li>Semestre: 6\u00ba</li> <li>Contato: listeror@al.insper.edu.br</li> <li>Ano: 2023</li> </ul>"},{"location":"#comecando","title":"Come\u00e7ando","text":"<p>Para seguir esse tutorial \u00e9 necess\u00e1rio:</p>"},{"location":"#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>Expliquem porque quiseram fazer esse tutorial.</p> <p>Info</p> <p>Essas duas partes s\u00e3o obrigat\u00f3rias no tutorial:</p> <pre><code>- Nome de voc\u00eas\n- Come\u00e7ando\n- Motiva\u00e7\u00e3o\n</code></pre>"},{"location":"#criando-uma-funcao-lambda-no-terraform","title":"Criando uma fun\u00e7\u00e3o Lambda no Terraform","text":"<p>O primeiro passo ser\u00e1 criarmos uma fun\u00e7\u00e3o lambda que, futuramente, ser\u00e1 integrada com o AWS API Gateway. Inicialmente, come\u00e7aremos com uma fun\u00e7\u00e3o simples sem nenhuma depend\u00eancia.</p> <p>Note</p> <p>Bloco de destaque de texto, pode ser:</p> <pre><code>- note, example, warning, info, tip, danger\n</code></pre> <p>Fa\u00e7a assim</p> <p>\u00c9 poss\u00edvel editar o t\u00edtulo desses blocos</p> <pre><code>!!! warning\n    Isso tamb\u00e9m \u00e9 poss\u00edvel de ser feito, mas\n    use com parcimonia.\n</code></pre> Info <p>Tamb\u00e9m da para esconder o texto, usar para coisas muito grandes, ou exemplos de c\u00f3digos.</p> <pre><code>```txt\n...\n\n\n\n\n\n\n\n\n\n\n\noi!\n```\n</code></pre> <ul> <li>Esse \u00e9 um texto em destaque</li> <li>Pode fazer isso tamb\u00e9m</li> </ul> <p>Usar emojis da lista:</p> <p> - https://github.com/caiyongji/emoji-list</p> index.js <pre><code>exports.handler = async (event) =&gt; {\nconsole.log(\"Event: \", event);\nlet responseMessage = \"Hello, World!\";\n\nif (event.queryStringParameters &amp;&amp; event.queryStringParameters[\"Name\"]) {\nresponseMessage = \"Hello, \" + event.queryStringParameters[\"Name\"] + \"!\";\n}\n\nreturn response;\n};\n</code></pre> <p>Ao invocar essa fun\u00e7\u00e3o com uma consulta de URL e com o par\u00e2metro Name definido, ela retornar\u00e1 \"Hello, Name!\".</p> <pre><code>// index.js\n\nexports.handler = async (event) =&gt; {\nconsole.log(\"Event: \", event);\nlet responseMessage = \"Hello, World!\";\n\nif (event.queryStringParameters &amp;&amp; event.queryStringParameters[\"Name\"]) {\nresponseMessage = \"Hello, \" + event.queryStringParameters[\"Name\"] + \"!\";\n}\n\nif (event.httpMethod === \"POST\") {\nconst body = JSON.parse(event.body);\nresponseMessage = \"Hello, \" + body.name + \"!\";\n}\n\nconst response = {\nstatusCode: 200,\nheaders: {\n\"Content-Type\": \"application/json\",\n},\nbody: JSON.stringify({\nmessage: responseMessage,\n}),\n};\n\nreturn response;\n};\n</code></pre> <p>Tamb\u00e9m ser\u00e1 verificado o m\u00e9todo HTTP GET e POST para que seja verificada a resposta padr\u00e3o. Foi especificado o c\u00f3digo de status '200', tipo de conte\u00fado e a mensagem para ser retornada ao chamador.</p> <p>Agora que nossa handler j\u00e1 est\u00e1 pronta, come\u00e7aremos a trabalhar em alguns elementos do nosso Terraform. Criaremos os arquivos .tf dentro de uma pasta intitulada (por motivos intuitivos, claro) como \"terraform\".</p> <p>Come\u00e7aremos criando o arquivo \"provider.tf\", em que ser\u00e3o declaradas as restri\u00e7\u00f5es de vers\u00e3o para os diferentes provedores AWS e afins.</p> terraform/provider.tf <pre><code>terraform {\nrequired_providers {\naws = {\nsource = \"hashicorp/aws\"\nversion = \"~&gt; 4.21.0\"\n}\n    //random = {\n    //    source = \"hashicorp/random\"\n    //    version = \"~&gt; 3.3.0\"\n    //    }\n    //archive = {\n    //    source = \"hashicorp/archive\"\n    //    version = \"~&gt; 2.2.0\"\n    //    }\n}\n\nrequired_version = \"~&gt; 1.0\"\n}\n\nprovider \"aws\" {\nregion = \"us-east-1\"\n}\n</code></pre> <p>Agora n\u00f3s construiremos uma fun\u00e7\u00e3o com todas as depend\u00eancias, empacotaremos como um arquivo zip para que, assim, consigamos subir num bucket do S3. Ou seja, quando criamos o lambda, apontamos para esse objeto de arquvo zip no bucket S3.</p> <p>Como os nomes dos buckets do S3 devem ser \u00fanicos e exclusivos no mundo inteiro, podemos utilizar um gerador aleat\u00f3rio para nos ajudar a nomear nosso bucket S3.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n</code></pre> <p>Em seguida, vamos criar o pr\u00f3prio bucket do S3 com o nome gerado.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n\n+resource \"aws_s3_bucket\" \"lambda_bucket\" {\n+  bucket        = random_pet.lambda_bucket_name.id\n+  force_destroy = true\n+}\n</code></pre> <p>Por padr\u00e3o, deixaremos todo o acesso p\u00fablico bloqueado.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n\nresource \"aws_s3_bucket\" \"lambda_bucket\" {\nbucket        = random_pet.lambda_bucket_name.id\nforce_destroy = true\n}\n\n+resource \"aws_s3_bucket_public_access_block\" \"lambda_bucket\" {\n+  bucket = aws_s3_bucket.lambda_bucket.id\n\n+  block_public_acls       = true\n+  block_public_policy     = true\n+  ignore_public_acls      = true\n+  restrict_public_buckets = true\n+}\n</code></pre> <p>Agora criaremos o c\u00f3digo Terraform do lambda. Lembrando que o lambda exigir\u00e1 acesso a outros servi\u00e7os da AWS (como o CloudWatch, para gravar logs) e, no nosso caso, concederemos acesso ao bucket do S3 para que seja poss\u00edvel a leitura de um arquivo.</p> <p>Para isso, precisamos criar uma fun\u00e7\u00e3o do IAM e permitir que o lambda a use.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n</code></pre> <p>O pr\u00f3ximo recurso ser\u00e1 criar a fun\u00e7\u00e3o lambda, a qual chamaremos de \"hello\". Em seguida especificaremos o nome do intervalo onde armazenaremos todos os lambdas. E nosso key pointing ir\u00e1 apontar para um arquivo zip com uma fun\u00e7\u00e3o.</p> <p>O hash do c\u00f3digo-fonte foi adicionado para reimplementar a fun\u00e7\u00e3o caso seja alterado/atualizado algo no c\u00f3digo-fonte. Se o hash do arquivo zip for diferente, a reimplanta\u00e7\u00e3o do lambda ser\u00e1 for\u00e7ada.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\n+resource \"aws_lambda_function\" \"hello\" {\n+  function_name = \"hello\"\n\n+  s3_bucket = aws_s3_bucket.lambda_bucket.id\n+  s3_key    = aws_s3_object.lambda_hello.key\n\n+  runtime = \"nodejs16.x\"\n+  handler = \"function.handler\"\n\n+  source_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\n+  role = aws_iam_role.hello_lambda_exec.arn\n+}\n</code></pre> <p>Para depurar, criamos um grupo de logs do CloudWatch que conseguisse armazenar todas as instru\u00e7\u00f5es e erros do console.log na fun\u00e7\u00e3o. Definimos a reten\u00e7\u00e3o para 30 dias, por\u00e9m poderia ser uma quantidade maior ou menor tamb\u00e9m, a depender das inten\u00e7\u00f5es de quem est\u00e1 desenvolvendo a infraestrutura (al\u00e9m dessas decis\u00f5es poderem afetar o custo de execu\u00e7\u00e3o do lambda).</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\n+resource \"aws_cloudwatch_log_group\" \"hello\" {\n+  name = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\n+  retention_in_days = 30\n+}\n</code></pre> <p>Em seguida, adicionaremos o recurso que empacota o lambda como um arquivo zip.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"hello\" {\nname = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\nretention_in_days = 14\n}\n\n+data \"archive_file\" \"lambda_hello\" {\n+  type = \"zip\"\n\n+  source_dir  = \"../${path.module}/hello\"\n+  output_path = \"../${path.module}/hello.zip\"\n+}\n</code></pre> <p>Nosso \u00faltimo componente visa obter o arquivo zip e carregar no bucket do S3.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"hello\" {\nname = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\nretention_in_days = 30\n}\n\ndata \"archive_file\" \"lambda_hello\" {\ntype = \"zip\"\n\nsource_dir  = \"../${path.module}/hello\"\noutput_path = \"../${path.module}/hello.zip\"\n}\n\n+resource \"aws_s3_object\" \"lambda_hello\" {\n+  bucket = aws_s3_bucket.lambda_bucket.id\n\n+  key    = \"hello.zip\"\n+  source = data.archive_file.lambda_hello.output_path\n\n+  etag = filemd5(data.archive_file.lambda_hello.output_path)\n+}\n</code></pre> <p>Com os passos feitos at\u00e9 aqui j\u00e1 conseguimos inicializar o terraform e aplicar suas altera\u00e7\u00f5es.</p> <pre><code>terraform init\nterraform apply\n</code></pre> <p>Qando o terraform concluir suas etapas at\u00e9 aqui, podemos entrar no dashboard da AWS e encontrar um bucket S3 rec\u00e9m-criado com um nome definido por meio de um gerador de animais de estima\u00e7\u00e3o aleat\u00f3rio.</p> <p>Note que dentro do bucket s\u00e3o armazenadas fun\u00e7\u00f5es lambdas dentro de um zip.</p> <p>Qaundo entramos na dashboard da AWS CloudWatch tamb\u00e9m conseguimos ver o grupo de logs criado.</p> <p>No dashboard do AWS Lambda conseguimos ver a fun\u00e7\u00e3o lambda empacotada como um zip.</p> <p>Como ainda n\u00e3o temos o API Gateway, conseguimos invocar a fun\u00e7\u00e3o com o comando aws lambda invoke. Lembre-se de especificar ou conferir se o nome da regi\u00e3o, fun\u00e7\u00e3o e arquivo est\u00e3o corretos pra registrar a resposta da fun\u00e7\u00e3o.</p> <pre><code>aws lambda invoke --region=us-east-1 --function-name=hello response.json\n</code></pre> <p>Ao printarmos a resposta, \u00e9 esperado um retorno \"Hello, World!\"</p> <pre><code>cat response.json\n</code></pre> <p>A pr\u00f3xima estapa ser\u00e1 criar o API Gateway e integr\u00e1-lo ao nosso lambda.</p> <p>Utilizaremos a vers\u00e3o 2 do API Gateway</p> terraform/api-gateway.tf <pre><code>resource \"aws_apigatewayv2_api\" \"main\" {\nname          = \"main\"\nprotocol_type = \"HTTP\"\n}\n\nresource \"aws_apigatewayv2_stage\" \"dev\" {\napi_id = aws_apigatewayv2_api.main.id\n\nname        = \"dev\"\nauto_deploy = true\n\naccess_log_settings {\ndestination_arn = aws_cloudwatch_log_group.main_api_gw.arn\n\nformat = jsonencode({\nrequestId               = \"$context.requestId\"\nsourceIp                = \"$context.identity.sourceIp\"\nrequestTime             = \"$context.requestTime\"\nprotocol                = \"$context.protocol\"\nhttpMethod              = \"$context.httpMethod\"\nresourcePath            = \"$context.resourcePath\"\nrouteKey                = \"$context.routeKey\"\nstatus                  = \"$context.status\"\nresponseLength          = \"$context.responseLength\"\nintegrationErrorMessage = \"$context.integrationErrorMessage\"\n}\n)\n}\n}\n\nresource \"aws_cloudwatch_log_group\" \"main_api_gw\" {\nname = \"/aws/api-gw/${aws_apigatewayv2_api.main.name}\"\n\nretention_in_days = 30\n}\n</code></pre> <p>No pr\u00f3ximo arquivo Terraform, integraremos o API Gateway com o hello lambda. Primeiramente apontaremos para o ID do API Gateway que acabamos de criar. Em seguida utilizaremos PROXYS AWS e solicita\u00e7\u00f5es POST para encaminhar solicita\u00e7\u00f5es do API Gateway para o Lambda</p> terraform/hello-api-gateway.tf <p><pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri = aws_lambda_function.hello.invoke_arn\nintegration_type = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n</code></pre> Podemos especificar qual tipo de solicita\u00e7\u00f5es queremos passar para o lambda, por exemplo: GET ou POST, como abaixo:</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri = aws_lambda_function.hello.invoke_arn\nintegration_type = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\n+resource \"aws_apigatewayv2_route\" \"get_hello\" {\n+api_id = aws_apigatewayv2_api.main.id\n\n+route_key = \"GET /hello\"\n+target = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n+}\n\n+resource \"aws_apigatewayv2_route\" \"post_hello\" {\n+api_id = aws_apigatewayv2_api.main.id\n\n+route_key = \"POST /hello\"\n+target = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n+}\n</code></pre> <p>Note que em ambos os exemplos \u00e9 necess\u00e1rio especificar um destino para ser o nosso lambda. Tamb\u00e9m precisamos conceder permiss\u00f5es ao API Gateway para invocar nossa fun\u00e7\u00f5 lambda:</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri    = aws_lambda_function.hello.invoke_arn\nintegration_type   = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"GET /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_apigatewayv2_route\" \"post_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"POST /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\n+resource \"aws_lambda_permission\" \"api_gw\" {\n+  statement_id  = \"AllowExecutionFromAPIGateway\"\n+  action        = \"lambda:InvokeFunction\"\n+  function_name = aws_lambda_function.hello.function_name\n+  principal     = \"apigateway.amazonaws.com\"\n\n+  source_arn = \"${aws_apigatewayv2_api.main.execution_arn}/*/*\"\n+}\n</code></pre> <p>Por fim, vamos imprimir no console o URL que podemos usar para invocar o lambda.</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri    = aws_lambda_function.hello.invoke_arn\nintegration_type   = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"GET /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_apigatewayv2_route\" \"post_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"POST /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_lambda_permission\" \"api_gw\" {\nstatement_id  = \"AllowExecutionFromAPIGateway\"\naction        = \"lambda:InvokeFunction\"\nfunction_name = aws_lambda_function.hello.function_name\nprincipal     = \"apigateway.amazonaws.com\"\n\nsource_arn = \"${aws_apigatewayv2_api.main.execution_arn}/*/*\"\n}\n\n+output \"hello_base_url\" {\n+  value = aws_apigatewayv2_stage.dev.invoke_url\n+}\n</code></pre> <p>No terminal, daremos um apply no teraform.</p> <pre><code>terraform apply\n</code></pre> <p>Se entrarmos no dashboard do API Gateway, podemos ver nosso est\u00e1gio de desenvolvimento \"dev\" criado e, em \"rotas\", conseguimos encontrar os m\u00e9todos GET e POST.</p> <p>Vamos agora testar o m\u00e9todo HTTP GET. A fun\u00e7\u00e3o deve analis\u00e1-lo e retornar a mensagem \"Ol\u00e1, + par\u00e2metro de URL\"</p> <pre><code>curl \"https://&lt;id&gt;.execute-api.us-east-1.amazonaws.com/dev/hello?Name=Anton\"\n</code></pre> <p>Tamb\u00e9m testaremos o m\u00e9todo POST. Nesse caso, fornecemos um payload como um objeto json para o terminal e veremos que funciona tmb\u00e9m.</p> <pre><code>curl -X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\":\"Anton\"}' \\\n\"https://&lt;id&gt;.execute-api.us-east-1.amazonaws.com/dev/hello\"\n</code></pre> <p>Se entrarmos no dashboard do CloudWatch, conseguiremos ver os logs de acesso registrados para cada solicita\u00e7\u00e3o.</p>"}]}
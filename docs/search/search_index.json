{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AWS S3 SERVELESS APPLICATION | COMPUTA\u00c7\u00c3O EM NUVEM - INSPER","text":"Sobre o Desenvolvedor Github <pre>\nAluno: Lister Ogusuku Ribeiro\nCurso: Engenharia de Computa\u00e7\u00e3o\nSemestre: 6\u00ba\nContato: listeror@al.insper.edu.br\nSemestre: 2023.1\n</pre> Lister OgusukuDeveloper"},{"location":"#cloud-computing-computacao-em-nuvem","title":"Cloud Computing (Computa\u00e7\u00e3o em Nuvem)","text":"<p>A computa\u00e7\u00e3o em nuvem \u00e9 um modelo de tecnologia de informa\u00e7\u00e3o que permite o acesso sob demanda a um conjunto compartilhado de recursos de computa\u00e7\u00e3o, como servidores, armazenamento, aplicativos e servi\u00e7os, por meio da internet. Em outras palavras, a computa\u00e7\u00e3o em nuvem \u00e9 uma forma de disponibilizar recursos computacionais atrav\u00e9s da internet, em vez de ter todos os recursos armazenados localmente em um \u00fanico computador ou servidor. Esses recursos s\u00e3o gerenciados e mantidos por provedores de servi\u00e7os em nuvem, como a Amazon Web Services, Microsoft Azure e Google Cloud Platform.</p> <p>A computa\u00e7\u00e3o em nuvem pode ser utilizada para diversas finalidades, como armazenar arquivos e documentos, hospedar aplicativos, desenvolver e testar software, processar dados em larga escala, entre outras. A principal vantagem da computa\u00e7\u00e3o em nuvem \u00e9 que ela permite que as empresas e usu\u00e1rios finais utilizem recursos computacionais de forma flex\u00edvel e escal\u00e1vel, sem precisar investir em infraestrutura de TI pr\u00f3pria. Al\u00e9m disso, a computa\u00e7\u00e3o em nuvem oferece maior disponibilidade e seguran\u00e7a de dados do que solu\u00e7\u00f5es locais, j\u00e1 que os provedores de servi\u00e7os em nuvem costumam ter data centers redundantes e medidas de seguran\u00e7a avan\u00e7adas para proteger os dados dos usu\u00e1rios.</p>"},{"location":"#sobre-o-projeto","title":"Sobre o Projeto","text":"<p>O Projeto a seguir visa aplicar conceitos de Computa\u00e7\u00e3o em Nuvem (Cloud Computing) por meio da AWS (Amazon Web Services). A ideia \u00e9 subir uma aplica\u00e7\u00e3o sem servidor utilizando o S3, Lambda, API Gateway e o CloudWatch.</p>"},{"location":"#desenvolvendo-a-infraestrutura","title":"Desenvolvendo a infraestrutura","text":""},{"location":"#1-instalacao-do-terraform","title":"1. Instala\u00e7\u00e3o do Terraform","text":"<p>A primeira etapa para desenvolvermos essa aplica\u00e7\u00e3o \u00e9 instalar o Terraform na m\u00e1quina. O Terraform \u00e9 uma ferramenta de gerenciamento de infraestrutura como c\u00f3digo (IaC) desenvolvida pela HashiCorp. Ele permite que os usu\u00e1rios definam, configurem e provisionem infraestruturas de forma automatizada e reprodut\u00edvel, usando uma linguagem declarativa e uma sintaxe simples. Com o Terraform, \u00e9 poss\u00edvel criar e gerenciar recursos em diferentes provedores de nuvem, como AWS, Google Cloud, Azure e outros, bem como em plataformas de infraestrutura, como Kubernetes, Docker e OpenStack. Em resumo, o Terraform \u00e9 uma ferramenta importante para automatizar e gerenciar infraestruturas de nuvem e outras plataformas de infraestrutura, tornando a gest\u00e3o de infraestrutura escal\u00e1vel, segura e repet\u00edvel.</p> <p>Caso voc\u00ea n\u00e3o possua o Terraform no seu computador, \u00e9 necess\u00e1rio baixar e instalar de acordo com o tutorial presente neste link.</p>"},{"location":"#2-utilizacao","title":"2. Utiliza\u00e7\u00e3o","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o do Terraform na m\u00e1quina, j\u00e1 \u00e9 poss\u00edvel rodar a infraestrutura desenvolvida.</p> <p>O primeiro passo \u00e9 clonar este reposit\u00f3rio em uma pasta dentro do seu computador. Caso n\u00e3o saiba como clonar um reposit\u00f3rio na sua m\u00e1quina local, acesse o tutorial presente neste link ou fa\u00e7a o download do resposit\u00f3rio e descompacte o arquivo .zip no local desejado.</p>"},{"location":"#criando-uma-funcao-lambda-no-terraform","title":"Criando uma fun\u00e7\u00e3o Lambda no Terraform","text":"<p>O primeiro passo ser\u00e1 criarmos uma fun\u00e7\u00e3o lambda que, futuramente, ser\u00e1 integrada com o AWS API Gateway. Inicialmente, come\u00e7aremos com uma fun\u00e7\u00e3o simples sem nenhuma depend\u00eancia.</p> index.js <pre><code>exports.handler = async (event) =&gt; {\nconsole.log(\"Event: \", event);\nlet responseMessage = \"Hello, World!\";\n\nif (event.queryStringParameters &amp;&amp; event.queryStringParameters[\"Name\"]) {\nresponseMessage = \"Hello, \" + event.queryStringParameters[\"Name\"] + \"!\";\n}\n\nreturn response;\n};\n</code></pre> <p>Ao invocar essa fun\u00e7\u00e3o com uma consulta de URL e com o par\u00e2metro Name definido, ela retornar\u00e1 \"Hello, Name!\".</p> index.js <pre><code>exports.handler = async (event) =&gt; {\nconsole.log(\"Event: \", event);\nlet responseMessage = \"Hello, World!\";\n\nif (event.queryStringParameters &amp;&amp; event.queryStringParameters[\"Name\"]) {\nresponseMessage = \"Hello, \" + event.queryStringParameters[\"Name\"] + \"!\";\n}\n\nif (event.httpMethod === \"POST\") {\nconst body = JSON.parse(event.body);\nresponseMessage = \"Hello, \" + body.name + \"!\";\n}\n\nconst response = {\nstatusCode: 200,\nheaders: {\n\"Content-Type\": \"application/json\",\n},\nbody: JSON.stringify({\nmessage: responseMessage,\n}),\n};\n\nreturn response;\n};\n</code></pre> <p>Tamb\u00e9m ser\u00e1 verificado o m\u00e9todo HTTP GET e POST para que seja verificada a resposta padr\u00e3o. Foi especificado o c\u00f3digo de status '200', tipo de conte\u00fado e a mensagem para ser retornada ao chamador.</p>"},{"location":"#criando-o-provider","title":"Criando o provider","text":"<p>Agora que nossa handler j\u00e1 est\u00e1 pronta, come\u00e7aremos a trabalhar em alguns elementos do nosso Terraform. Criaremos os arquivos .tf dentro de uma pasta intitulada (por motivos intuitivos, claro) como \"terraform\".</p> <p>Come\u00e7aremos criando o arquivo \"provider.tf\", em que ser\u00e3o declaradas as restri\u00e7\u00f5es de vers\u00e3o para os diferentes provedores AWS e afins.</p> terraform/provider.tf <pre><code>terraform {\nrequired_providers {\naws = {\nsource = \"hashicorp/aws\"\nversion = \"~&gt; 4.21.0\"\n}\n    //random = {\n    //    source = \"hashicorp/random\"\n    //    version = \"~&gt; 3.3.0\"\n    //    }\n    //archive = {\n    //    source = \"hashicorp/archive\"\n    //    version = \"~&gt; 2.2.0\"\n    //    }\n}\n\nrequired_version = \"~&gt; 1.0\"\n}\n\nprovider \"aws\" {\nregion = \"us-east-1\"\n}\n</code></pre>"},{"location":"#bucket-do-s3","title":"Bucket do S3","text":"<p>Agora n\u00f3s construiremos uma fun\u00e7\u00e3o com todas as depend\u00eancias, empacotaremos como um arquivo zip para que, assim, consigamos subir num bucket do S3. Ou seja, quando criamos o lambda, apontamos para esse objeto de arquvo zip no bucket S3.</p> <p>Como os nomes dos buckets do S3 devem ser \u00fanicos e exclusivos no mundo inteiro, podemos utilizar um gerador aleat\u00f3rio para nos ajudar a nomear nosso bucket S3.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n</code></pre> <p>Em seguida, vamos criar o pr\u00f3prio bucket do S3 com o nome gerado.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n\n+resource \"aws_s3_bucket\" \"lambda_bucket\" {\n+  bucket        = random_pet.lambda_bucket_name.id\n+  force_destroy = true\n+}\n</code></pre> <p>Por padr\u00e3o, deixaremos todo o acesso p\u00fablico bloqueado.</p> terraform/lambda-bucket.tf <pre><code>resource \"random_pet\" \"lambda_bucket_name\" {\nprefix = \"lambda\"\nlength = 2\n}\n\nresource \"aws_s3_bucket\" \"lambda_bucket\" {\nbucket        = random_pet.lambda_bucket_name.id\nforce_destroy = true\n}\n\n+resource \"aws_s3_bucket_public_access_block\" \"lambda_bucket\" {\n+  bucket = aws_s3_bucket.lambda_bucket.id\n\n+  block_public_acls       = true\n+  block_public_policy     = true\n+  ignore_public_acls      = true\n+  restrict_public_buckets = true\n+}\n</code></pre>"},{"location":"#iam-e-policies","title":"IAM e Policies","text":"<p>Agora criaremos o c\u00f3digo Terraform do lambda. Lembrando que o lambda exigir\u00e1 acesso a outros servi\u00e7os da AWS (como o CloudWatch, para gravar logs) e, no nosso caso, concederemos acesso ao bucket do S3 para que seja poss\u00edvel a leitura de um arquivo.</p> <p>Para isso, precisamos criar uma fun\u00e7\u00e3o do IAM e permitir que o lambda a use.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n</code></pre>"},{"location":"#criando-uma-funcao-lambda","title":"Criando uma fun\u00e7\u00e3o Lambda","text":"<p>O pr\u00f3ximo recurso ser\u00e1 criar a fun\u00e7\u00e3o lambda, a qual chamaremos de \"hello\". Em seguida especificaremos o nome do intervalo onde armazenaremos todos os lambdas. E nosso key pointing ir\u00e1 apontar para um arquivo zip com uma fun\u00e7\u00e3o.</p> <p>O hash do c\u00f3digo-fonte foi adicionado para reimplementar a fun\u00e7\u00e3o caso seja alterado/atualizado algo no c\u00f3digo-fonte. Se o hash do arquivo zip for diferente, a reimplanta\u00e7\u00e3o do lambda ser\u00e1 for\u00e7ada.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\n+resource \"aws_lambda_function\" \"hello\" {\n+  function_name = \"hello\"\n\n+  s3_bucket = aws_s3_bucket.lambda_bucket.id\n+  s3_key    = aws_s3_object.lambda_hello.key\n\n+  runtime = \"nodejs16.x\"\n+  handler = \"function.handler\"\n\n+  source_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\n+  role = aws_iam_role.hello_lambda_exec.arn\n+}\n</code></pre>"},{"location":"#criando-cloudwatch","title":"Criando CloudWatch","text":"<p>Para depurar, criamos um grupo de logs do CloudWatch que conseguisse armazenar todas as instru\u00e7\u00f5es e erros do console.log na fun\u00e7\u00e3o. Definimos a reten\u00e7\u00e3o para 30 dias, por\u00e9m poderia ser uma quantidade maior ou menor tamb\u00e9m, a depender das inten\u00e7\u00f5es de quem est\u00e1 desenvolvendo a infraestrutura (al\u00e9m dessas decis\u00f5es poderem afetar o custo de execu\u00e7\u00e3o do lambda).</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\n+resource \"aws_cloudwatch_log_group\" \"hello\" {\n+  name = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\n+  retention_in_days = 30\n+}\n</code></pre> <p>Em seguida, adicionaremos o recurso que empacota o lambda como um arquivo zip.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"hello\" {\nname = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\nretention_in_days = 14\n}\n\n+data \"archive_file\" \"lambda_hello\" {\n+  type = \"zip\"\n\n+  source_dir  = \"../${path.module}/hello\"\n+  output_path = \"../${path.module}/hello.zip\"\n+}\n</code></pre> <p>Nosso \u00faltimo componente visa obter o arquivo zip e carregar no bucket do S3.</p> terraform/hello-lambda.tf <pre><code>resource \"aws_iam_role\" \"hello_lambda_exec\" {\nname = \"hello-lambda\"\n\nassume_role_policy = &lt;&lt;POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"hello_lambda_policy\" {\nrole       = aws_iam_role.hello_lambda_exec.name\npolicy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"hello\" {\nfunction_name = \"hello\"\n\ns3_bucket = aws_s3_bucket.lambda_bucket.id\ns3_key    = aws_s3_object.lambda_hello.key\n\nruntime = \"nodejs16.x\"\nhandler = \"function.handler\"\n\nsource_code_hash = data.archive_file.lambda_hello.output_base64sha256\n\nrole = aws_iam_role.hello_lambda_exec.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"hello\" {\nname = \"/aws/lambda/${aws_lambda_function.hello.function_name}\"\n\nretention_in_days = 30\n}\n\ndata \"archive_file\" \"lambda_hello\" {\ntype = \"zip\"\n\nsource_dir  = \"../${path.module}/hello\"\noutput_path = \"../${path.module}/hello.zip\"\n}\n\n+resource \"aws_s3_object\" \"lambda_hello\" {\n+  bucket = aws_s3_bucket.lambda_bucket.id\n\n+  key    = \"hello.zip\"\n+  source = data.archive_file.lambda_hello.output_path\n\n+  etag = filemd5(data.archive_file.lambda_hello.output_path)\n+}\n</code></pre>"},{"location":"#inicializando-o-terraform","title":"Inicializando o Terraform","text":"<p>Com os passos feitos at\u00e9 aqui j\u00e1 conseguimos inicializar o terraform e aplicar suas altera\u00e7\u00f5es.</p> <pre><code>terraform init\nterraform apply\n</code></pre> <p> Dica visual</p> <p>Quando o terraform concluir suas etapas at\u00e9 aqui, podemos entrar no dashboard da AWS e encontrar um bucket S3 rec\u00e9m-criado com um nome definido por meio de um gerador de animais de estima\u00e7\u00e3o aleat\u00f3rio.</p> <p>Para abstrair:</p> <p>Note que dentro do bucket s\u00e3o armazenadas fun\u00e7\u00f5es lambdas dentro de um zip.</p> <p>Quando entramos na dashboard da AWS CloudWatch tamb\u00e9m conseguimos ver o grupo de logs criado.</p> <p>No dashboard do AWS Lambda conseguimos ver a fun\u00e7\u00e3o lambda empacotada como um zip.</p> <p>Como ainda n\u00e3o temos o API Gateway, conseguimos invocar a fun\u00e7\u00e3o com o comando aws lambda invoke.</p> <p>Lembre-se de especificar ou conferir se o nome da regi\u00e3o, fun\u00e7\u00e3o e arquivo est\u00e3o corretos pra registrar a resposta da fun\u00e7\u00e3o.</p> <pre><code>aws lambda invoke --region=us-east-1 --function-name=hello response.json\n</code></pre> <p>Ao printarmos a resposta, \u00e9 esperado um retorno \"Hello, World!\"</p> <pre><code>cat response.json\n</code></pre>"},{"location":"#criando-o-api-gateway","title":"Criando o API Gateway","text":"<p>A pr\u00f3xima estapa ser\u00e1 criar o API Gateway e integr\u00e1-lo ao nosso lambda.</p> <p>Utilizaremos a vers\u00e3o 2 do API Gateway.</p> terraform/api-gateway.tf <pre><code>resource \"aws_apigatewayv2_api\" \"main\" {\nname          = \"main\"\nprotocol_type = \"HTTP\"\n}\n\nresource \"aws_apigatewayv2_stage\" \"dev\" {\napi_id = aws_apigatewayv2_api.main.id\n\nname        = \"dev\"\nauto_deploy = true\n\naccess_log_settings {\ndestination_arn = aws_cloudwatch_log_group.main_api_gw.arn\n\nformat = jsonencode({\nrequestId               = \"$context.requestId\"\nsourceIp                = \"$context.identity.sourceIp\"\nrequestTime             = \"$context.requestTime\"\nprotocol                = \"$context.protocol\"\nhttpMethod              = \"$context.httpMethod\"\nresourcePath            = \"$context.resourcePath\"\nrouteKey                = \"$context.routeKey\"\nstatus                  = \"$context.status\"\nresponseLength          = \"$context.responseLength\"\nintegrationErrorMessage = \"$context.integrationErrorMessage\"\n}\n)\n}\n}\n\nresource \"aws_cloudwatch_log_group\" \"main_api_gw\" {\nname = \"/aws/api-gw/${aws_apigatewayv2_api.main.name}\"\n\nretention_in_days = 30\n}\n</code></pre>"},{"location":"#integrando-o-api-gateway-com-o-lambda","title":"Integrando o API Gateway com o Lambda","text":"<p>No pr\u00f3ximo arquivo Terraform, integraremos o API Gateway com o hello lambda. Primeiramente apontaremos para o ID do API Gateway que acabamos de criar. Em seguida utilizaremos PROXYS AWS e solicita\u00e7\u00f5es POST para encaminhar solicita\u00e7\u00f5es do API Gateway para o Lambda</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri = aws_lambda_function.hello.invoke_arn\nintegration_type = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n</code></pre> <p>Podemos especificar qual tipo de solicita\u00e7\u00f5es queremos passar para o lambda, por exemplo: GET ou POST, como abaixo:</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri = aws_lambda_function.hello.invoke_arn\nintegration_type = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\n+resource \"aws_apigatewayv2_route\" \"get_hello\" {\n+api_id = aws_apigatewayv2_api.main.id\n\n+route_key = \"GET /hello\"\n+target = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n+}\n\n+resource \"aws_apigatewayv2_route\" \"post_hello\" {\n+api_id = aws_apigatewayv2_api.main.id\n\n+route_key = \"POST /hello\"\n+target = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n+}\n</code></pre> <p>Note que em ambos os exemplos \u00e9 necess\u00e1rio especificar um destino para ser o nosso lambda. Tamb\u00e9m precisamos conceder permiss\u00f5es ao API Gateway para invocar nossa fun\u00e7\u00e3o lambda:</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri    = aws_lambda_function.hello.invoke_arn\nintegration_type   = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"GET /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_apigatewayv2_route\" \"post_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"POST /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\n+resource \"aws_lambda_permission\" \"api_gw\" {\n+  statement_id  = \"AllowExecutionFromAPIGateway\"\n+  action        = \"lambda:InvokeFunction\"\n+  function_name = aws_lambda_function.hello.function_name\n+  principal     = \"apigateway.amazonaws.com\"\n\n+  source_arn = \"${aws_apigatewayv2_api.main.execution_arn}/*/*\"\n+}\n</code></pre>"},{"location":"#invocando-o-lambda","title":"Invocando o Lambda","text":"<p>Por fim, vamos imprimir no console o URL que podemos usar para invocar o lambda.</p> terraform/hello-api-gateway.tf <pre><code>resource \"aws_apigatewayv2_integration\" \"lambda_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nintegration_uri    = aws_lambda_function.hello.invoke_arn\nintegration_type   = \"AWS_PROXY\"\nintegration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"GET /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_apigatewayv2_route\" \"post_hello\" {\napi_id = aws_apigatewayv2_api.main.id\n\nroute_key = \"POST /hello\"\ntarget    = \"integrations/${aws_apigatewayv2_integration.lambda_hello.id}\"\n}\n\nresource \"aws_lambda_permission\" \"api_gw\" {\nstatement_id  = \"AllowExecutionFromAPIGateway\"\naction        = \"lambda:InvokeFunction\"\nfunction_name = aws_lambda_function.hello.function_name\nprincipal     = \"apigateway.amazonaws.com\"\n\nsource_arn = \"${aws_apigatewayv2_api.main.execution_arn}/*/*\"\n}\n\n+output \"hello_base_url\" {\n+  value = aws_apigatewayv2_stage.dev.invoke_url\n+}\n</code></pre> <p>No terminal, daremos um apply no teraform.</p> <pre><code>terraform apply\n</code></pre> <p> Dica visual</p> <p>Se entrarmos no dashboard do API Gateway, podemos ver nosso est\u00e1gio de desenvolvimento \"dev\" criado e, em \"rotas\", conseguimos encontrar os m\u00e9todos GET e POST.</p>"},{"location":"#hora-de-testar","title":"Hora de testar","text":"<p>Vamos agora testar o m\u00e9todo HTTP GET. A fun\u00e7\u00e3o deve analis\u00e1-lo e retornar a mensagem \"Ol\u00e1, + par\u00e2metro de URL\"</p> <pre><code>curl \"https://&lt;id&gt;.execute-api.us-east-1.amazonaws.com/dev/hello?Name=Anton\"\n</code></pre> <p>Tamb\u00e9m testaremos o m\u00e9todo POST. Nesse caso, fornecemos um payload como um objeto json para o terminal e veremos que funciona tmb\u00e9m.</p> <pre><code>curl -X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\":\"Anton\"}' \\\n\"https://&lt;id&gt;.execute-api.us-east-1.amazonaws.com/dev/hello\"\n</code></pre> <p>Se entrarmos no dashboard do CloudWatch, conseguiremos ver os logs de acesso registrados para cada solicita\u00e7\u00e3o.</p>"}]}